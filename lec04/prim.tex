אלגוריתם פרים מתחיל מעץ שמכיל צומת אחד ובכל איטרציה מוסיף לעץ את הקשת הכי זולה שקצה
אחד שלה בדיוק נוגע בעץ.
פורמלית:
\begin{enumerate}
\item
אתחול:
$U \leftarrow \{u\}, B \leftarrow \emptyset$, 
כאשר $u$ צומת שרירותי.
\item
כל עוד 
$T = (V, B)$
אינו קשיר הפעל את הכלל הכחול:
\begin{enumerate}
\item
בחר את החתך הלבן, $U$, וקשת קלה, $uv$, שחוצה אותו 
\item
$B \leftarrow B \cup \{uv\}$, 
$U \leftarrow U \cup \{v, u\}$
\end{enumerate}
\end{enumerate}
\begin{observation}
אלגוריתם פרים הוא מימוש של האלגוריתם הכללי שמפעיל את הכלל הכחול.
\end{observation}



\textbf{דוגמה:}

\begin{center}
\begin{tikzpicture}[
every node/.style={default node}
,x=1.7cm
,y=1.7cm
]

\foreach[count=\i] \x \y in {
0/0,0/1,1/0,1/1,-1/-1,-1/2,2/-1,2/2}{
\node(\i) at (\x, \y) {\i};
}

\foreach \u \v \w in {
3/1/1%
,1/2/2%
,2/4/2%
,4/3/2%
,5/6/3%
,6/8/4%
,8/7/5%
,7/5/6%
,6/2/7%
,8/4/8%
,7/3/8%
,5/1/8%
}{
\draw (\u) -- (\v) node[label above]{\w};
}

\begin{scope}[xshift=8cm]
\foreach[count=\i] \x \y in {
0/0,0/1,1/0,1/1,-1/-1,-1/2,2/-1,2/2}{
\node(\i) at (\x, \y) {\i};
}

\foreach[count=\i] \u \v in {
5/6%
,6/8%
,6/2%
,2/4%
,2/1%
,1/3%
,8/7%
}{
\draw (\u) -- (\v) node[label below, blue]{\i};
}
\end{scope}

\end{tikzpicture}
\end{center}




\textbf{הערות:}
\begin{itemize}
\item
כדי לממש את האלגוריתם צריך לדעת בכל שלב אילו קשתות חוצות את החתך ולבחור מהן את הקלה ביותר
\item
כאשר מוסיפים צומת לחתך יתכנו השינויים הבאים:
\begin{itemize}
\item
קשת שחצתה את החתך עכשיו היא פנימית לחתך
\item
קשת חיצונית לחתך עכשיו חוצה את החתך
\end{itemize}
\item
השינויים היחידים הם עבור קשתות שנוגעות בצומת שהוסף לחתך ולכן בכל פעם שמוסיפים צומת לחתך 
מעדכנים רק את הקשתות שנוגעות בו, סך הכל מעדכנים כל קשת פעמיים לכל היותר.
\item
נשים לב שאם שומרים את הקשתות שחוצות את החתך בערימת מינימום אז 
אנחנו מבצעים 
$|E|$
הכנסות ו-%
$|V|$
הוצאות.
הוצאה והכנסה של כל קשת לוקחת
$O(\log |E|)$
לכל היותר. 
\item
סך הכל זמן הריצה של האלגוריתם הוא
$O(|E|\log|E|) = O(|E|\log|V|)$
\item
קיימים מבני נתונים יותר יעילים עם פונקציונליות של ערימת מינימום 
שתומכים בהכנסה בזמן ממוצע
$O(1)$
והוצאה בזמן 
$O(\log |E|)$
ולכן ניתן לממש את האלגוריתם בזמן 
$O(|E| + |V|\log |V|)$
\end{itemize}
