אלגוריתם קרוסקל מתחיל מיער ללא קשתות, בכל שלב באלגוריתם נמזג שני רכיבי קשירות באמצעות
הקשת הקלה ביותר שמחברת שני רכיבי קשירות.

דוגמה:

\begin{center}
\begin{tikzpicture}[
every node/.style={default node}
,x=1.7cm
,y=1.7cm
]

\foreach[count=\i] \x \y in {
0/0,0/1,1/0,1/1,-1/-1,-1/2,2/-1,2/2}{
\node(\i) at (\x, \y) {\i};
}

\foreach \u \v \w in {
3/1/1%
,1/2/2%
,2/4/2%
,4/3/2%
,5/6/3%
,6/8/4%
,8/7/5%
,7/5/6%
,6/2/7%
,8/4/8%
,7/3/8%
,5/1/8%
}{
\draw (\u) -- (\v) node[label above]{\w};
}

\begin{scope}[xshift=8cm]
\foreach[count=\i] \x \y in {
0/0,0/1,1/0,1/1,-1/-1,-1/2,2/-1,2/2}{
\node(\i) at (\x, \y) {\i};
}

\foreach[count=\i] \u \v in {
1/3%
,4/2%
,4/3%
,5/6%
,6/8%
,8/7%
,6/2%
}{
\draw (\u) -- (\v) node[label above, blue]{\i};
}
\end{scope}

\end{tikzpicture}
\end{center}

פורמלית:
\begin{enumerate}
\item
אתחול:
$C \leftarrow \{\{v\} : v \in V \}$, 
\item
כל עוד 
$|C| > 1$
\begin{enumerate}
בחר את הקשת עם המשקל המינימלי שמחברת שני רכיבי קשירות, הפעל עליה את הכלל הכחול ועדכן 
את $C$ בהתאם
\end{enumerate}
\end{enumerate}
\textbf{הערות:}
\begin{itemize}
\item
ניתן לממש את האלגוריתם באופן הבא:
\begin{itemize}
\item
מיין את הקשתות בסדר לא יורד של משקלן
\item
עבור כל קשת לפי הסדר, אם היא מחברת שני רכיבי קשירות הפעל עליה את הכלל הכחול ועדכן את $C$
\end{itemize}
\item
זמן הריצה של מימוש כזה הוא 
$O(|E| \log |E|)$
עבור המיון ובנוסף לכל קשת צריך לבדוק אם היא מחברת שני רכיבים שונים ואם כן לעדכן את מבנה הרכיבים.
כזכור מקורס מבני נתונים קיים מימוש פשוט שעושה זאת בזמן ממוצע של 
$O(\log |V|)$
ולכן הזמן הריצה הכולל הוא 
$O(|E| \log |E|) = O(|E| \log |V|)$.

\end{itemize}
