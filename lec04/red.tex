בחלק זה נראה אלגוריתם גנרי שפועל על פי הכלל האדום.

\begin{definition}[מעגל לבן]
בהינתן גרף לא מכוון
$G = (V,E)$
ותת קבוצה של קשתות אדומות
$R \subseteq E$
מעגל $C$ יקרא לבן אם לא הוא לא מכיל קשת אדומה.
\end{definition}
\begin{definition}[קשת כבדה]
בהינתן מעגל, $C$, ופונקצית משקל, 
$w: E \to \mathbb{R}$,
קשת $e$ במעגל $C$ תקרא כבדה אם לא קיימת קשת אחרת במעגל $C$, 
$e'$
שמקיימת 
$w(e') > w(e)$.
\end{definition}
\begin{enumerate}
\item
אתחול:
$R \leftarrow \emptyset$ 
(קשתות אדומות)
\item
כל עוד ב-%
$T = (V, E \setminus R)$
יש מעגל הפעל את הכלל האדום:
\begin{enumerate}
\item
בחר מעגל לבן, $C$, וקשת כבדה, $e$, על המעגל
\item
$R \leftarrow R \cup \{e\}$
\end{enumerate}
\end{enumerate}

\textbf{הערה:}
במקום לצבוע את הקשת באדום ניתן פשוט למחוק אותה מהגרף
\begin{claim}
בסיום האלגוריתם $T$ הוא עץ
\end{claim}
\begin{proof}
חוסר מעגלים נובע מיידית מהגדרת האלגוריתם.
נניח בשלילה שאלגוריתם פוגע בקשירות, כלומר קיים חתך כך שהאלגוריתם צובע באדום את כל הקשתות 
שחוצות אותו, נסתכל על הקשת האחרונה שנצבעה באדום ועל המעגל הלבן שגרם לה להיבחר לפי אבחנה 
\ref{observation:cycle}
קיימת קשת לבנה נוספת שחוצה את החתך - סתירה.
\end{proof}

\begin{claim}
\label{claim:red}
האלגוריתם מחזיר עץ פורש מינימלי
\end{claim}

\begin{proof}
נוכיח באינדוקציה שבכל שלב בריצת האלגוריתם אוסף הקשתות הלבנות מכילות עץ פורש מינימלי כלשהו:

בסיס: טריוויאלי באתחול

צעד: לפי ההנחה אוסף הקשתות הלבנות בצעד ה-$i$ מכילות עפ"מ כלשהו.
נניח שהקשת, $e$, שמחקנו בשלב ה-%
$i+1$
שייכת לעפ"מ הנ"ל (אחרת סיימנו).
נסתכל על החתך שמחיקת הקשת יוצרת, ועל המעגל (הלבן) שגרם למחיקת הקשת,
אז קיימת קשת נוספת על המעגל שחוצה את החתך, 
$e' \neq e$
כך ש-%
$w(e) \geq w(e')$
ולכן ניתן להחליף בין הקשתות הנ"ל כך שהעפ"מ החדש מוכל כולו בקשתות לבנות.
\end{proof}


