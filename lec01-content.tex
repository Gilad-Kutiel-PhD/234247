\section*{הקדמה}
\begin{displayquote}
אלגוריתם הוא דרך שיטתית (כלומר כזו שצעדיה מוגדרים היטב) לביצוע של משימה מסוימת, 
במספר סופי של צעדים.
\end{displayquote}
\leftline{\textenglish{---} \textit{ויקיפדיה}}
המושג אלגוריתם אינו חדש עבורנו, ראינו ומימשנו כבר אלגוריתמים בקורס מבוא למדעי המחשב, 
מבוא לתכנות מערכות ומבני נתונים.
\subsection*{חשיבות הקורס}
בתעשייה - בעיות שמצריכות פתרון אלגוריתמי צצות במגוון תחומים. על פי
\textenglish{glassdoor}, 
מפתח אלגוריתמים מרוויח 20 אחוז יותר מאשר מהנדס תוכנה.
\\
במחקר האקדמי - חלק עיקרי של המחקר האקדמי הוא בפיתוח וניתוח אלגוריתמים.
\subsection*{חומר הקורס}
בקורס נלמד מגוון אלגוריתמים שעל פי רוב נחשבים לבסיס בתחום האלגוריתמים.
הרוב המוחלט של האלגוריתמים שנלמד בקורס הם אלגוריתמים על גרפים 
וזאת מכיוון שגרפים הוכיחו את עצמם ככלי מאוד חזק בייצוג מגוון רחב של בעיות.
לחלק מהאלגוריתמים שימושים ברורים (מסלול קצר ביותר, עצי הופמן), 
חלק מהאלגוריתמים מהווים פתרון למגוון גדול של בעיות שניתנות לייצוג בצורה מסוימת (זרימה), 
וחלק מהאלגוריתמים מהווים בסיס לפיתוח אלגוריתמים מורכבים יותר (%
\textenglish{BFS},
\textenglish{DFS}, 
עץ פורש).
מעבר לזה נלמד טכניקות (פשוטות יחסית) כלליות לפיתוח אלגוריתמים.
\section*{אלגוריתמי חיפוש בגרפים}
\begin{example}
רוצים למצוא (ולהדפיס) את כל קבצי התמונות ששמורות על הכונן הקשיח.
\end{example}
למשל עבור:
\begin{center}
\begin{tikzpicture}[every node/.style={
	rectangle
%	, minimum width=1.5cm
%	, draw
	, text width=1.5cm
	, x=2.2cm
}, ->]

\node[text width=2mm](0) at(0,1) {/};
\foreach [count=\i] \x \y \name in {
	1/0/Documents
	, 1/-1/Downloads
	, 1/-2/Music
	, 1/-3/Pictures
	, 2/-1.5/Image1.jpg
	, 2/-3.5/Image2.jpg	
}{
	\node(\i) at(\x, \y) {\name};
}

\foreach \i in {1,...,4}{
	\draw (0) |- (\i);
}
\draw (2) |- (5);
\draw (4) |- (6);

\end{tikzpicture}
\end{center}

כיצד עלינו לסרוק (לחפש) את מערכת הקבצים ? 
\begin{enumerate}
\item
במידה ורוצים להדפיס את (הנתיב המלא של) הקבצים בסדר לקסיקוגרפי ?
\item
במידה ורוצים להדפיס קבצים לפי העומק שלהם (מספר תיקיות) ?
\end{enumerate}
נשים לב שאפשר לייצג את מערכת הקבצים באמצעות גרף מכוון (ברוב מערכות הקבצים עץ אינו ייצוג מספק)
ולכן נעביר את הדיון שלנו לחיפוש בגרפים.

\subsection*{ייצוג גרפים}
קיימים שני ייצוגים סטנדרטים של גרפים (מכוונים או לא):
\begin{enumerate}
\item
על ידי מטריצת שכנויות
\item
על ידי רשימת שכנויות
\end{enumerate}
אם לא מצוין אחרת, נניח שהגרף מיוצג על ידי רשימת שכנויות.



\subsection*{אלגוריתם כללי}
\textbf{קלט:}
גרף $G$ (מכוון או לא) וצומת מקור $s$.
\\
\textbf{מטרה:}
למצוא תת עץ שפורש את כל הצמתים שישיגים מ-$s$.
\\
למשל:
\begin{center}
\begin{tikzpicture}[every node/.style={circle, draw, minimum width=5mm}]

\node(s) at(0,0) {s};
\foreach [count=\i] \x\y in {-1/-1,1/-1,0/-2}{
	\node(\i) at(\x,\y) {\i};
}

\foreach \u \v in {
s/1%
,s/2%
,1/2%
,1/3%
,2/3%
}{
	\draw (\u) -- (\v);
}

\begin{scope}[xshift=6cm]
\node(s) at(0,0) {s};
\foreach [count=\i] \x\y in {-1/-1,1/-1,0/-2}{
	\node(\i) at(\x,\y) {\i};
}

\foreach \u \v in {
s/1%
,1/2%
,1/3%
}{
	\draw[->] (\u) -- (\v);
}
\end{scope}

\end{tikzpicture}
\end{center}

\begin{definition}[חתך]
חתך בגרף,
$G = (V, E)$,
הוא תת קבוצה של צמתים. 
$S \subseteq V$
נאמר שקשת 
$uv \in E$
\emph{חוצה}
את החתך $S$ אם
$u \in S$
ו-%
$v \notin S$.
\end{definition}
\begin{enumerate}
\item 
אתחול:
$T \leftarrow \emptyset$, 
$U \leftarrow \{s\}$
ולכל 
$v \in V$
מציבים 
$p(v) \leftarrow \text{nil}$
\item
כל עוד יש קשת
$uv$
שחוצה את $U$
	\begin{enumerate}
	\item
	$U \leftarrow U \cup \{v\}$,
	$T \leftarrow T \cup \{uv\}$,
	$p(v) \leftarrow u$
	\end{enumerate}
\end{enumerate}

\begin{claim}
בסיום ריצת האלגוריתם
$U$
מכילה את כל הצמתים הישיגים מ-$s$
\end{claim}
\begin{proof}
בשלילה, בוחרים מסלול מ-$s$ לצומת $v$ שלא נכנס ל-%
$U$
ומסתכלים על הצומת הראשון במסלול שלא נכנס.
\end{proof}
\begin{claim}
בכל שלב בריצת האלגוריתם
$T$
עץ קשיר
\end{claim}
\begin{proof}
באינדוקציה על צעד האלגוריתם.
\end{proof}
\begin{theorem}
בסיום ריצת האלגוריתם הכללי $T$ הוא עץ שפורש את כל הצמתים הישיגים מ-$s$
\end{theorem}





\subsection*{%
חיפוש לרוחב - 
\textenglish{Breadth First Search (BFS)}
}
\begin{definition}[מרחק]
בהינתן גרף 
$G = (V, E)$,
נגדיר את 
\emph{המרחק}
בין שני צמתים 
$u,v \in V$,
ונסמנו 
$dist_G(u,v)$,
כמספר הקשתות המינימלי במסלול מ-$u$ ל-$v$.
\end{definition}
\noindent
\textbf{הערה:}
כאשר ברור על איזה גרף מדובר נסתפק בסימון 
$dist(u,v)$.
\vspace{5mm}
\\
\textbf{קלט:}
גרף $G$ (מכוון או לא) וצומת מקור $s$.
\\
\textbf{מטרה:}
למצוא תת עץ, $T$, שפורש את כל הצמתים שישיגים מ-$s$ כך שלכל צומת 
$v \in V$
מתקיים
$dist_T(s, v) = dist_G(s, v)$.
\\
למשל:
\begin{center}
\begin{tikzpicture}[every node/.style={circle, draw, minimum width=5mm}]

\node(s) at(0,0) {s};
\foreach [count=\i] \x\y in {-1/-1,1/-1,0/-2}{
	\node(\i) at(\x,\y) {\i};
}

\foreach \u \v in {
s/1%
,s/2%
,1/2%
,1/3%
,2/3%
}{
	\draw (\u) -- (\v);
}

\begin{scope}[xshift=6cm]
\node(s) at(0,0) {s};
\foreach [count=\i] \x\y in {-1/-1,1/-1,0/-2}{
	\node(\i) at(\x,\y) {\i};
}

\foreach \u \v in {
s/1%
,s/2%
,1/3%
}{
	\draw[->] (\u) -- (\v);
}
\end{scope}

\end{tikzpicture}
\end{center}

\begin{enumerate}
\item
אתחול:
$U \leftarrow \{s\}, T \leftarrow \emptyset, i \leftarrow 0$, 
לכל 
$v \in V$
מציבים
$p(v) \leftarrow nil, d(v) \leftarrow \infty$,
$d(s) \leftarrow 0$
\item 
כל עוד קיים צומת $u$ כך ש-%
$d(u) = i$
\label{item:bfs:while}
\begin{enumerate}
	\item 
	כל עוד ישנה קשת 
	$uv$
	שחוצה את $U$ ו-%
	$d(u) = i$
		\begin{enumerate}
		\item
		$U \leftarrow U \cup \{v\}, T \leftarrow T \cup \{uv\}$
		\item
		$p(v) = u, d(v) = i + 1$
		\end{enumerate}
	\item
	$i \leftarrow i+1$
	\end{enumerate}
\end{enumerate}
\begin{claim}
בסוף ריצת האלגוריתם לא קיימת קשת 
$uv$
שחוצה את $U$.
\end{claim}
\begin{proof}
בשלילה, אם קיימת ו-%
$d(u) = i$
אז באיטרציה ה-%
$i$
היינו מוסיפים אותה
\end{proof}

\begin{corollary}
BFS
הוא מקרה פרטי של האלגוריתם הכללי
\end{corollary}

\begin{claim}
לכל
$v \in V$
מתקיים
$dist_T(s, v) = d(v)$
\end{claim}
\begin{proof}
באינדוקציה על צעד האלגוריתם
\end{proof}

\begin{claim}
לכל
$v \in V$
מתקיים
$dist_T(s, v) \leq dist_G(s,v)$
\end{claim}
\begin{proof}
באינדוקציה על צעד האלגוריתם
\end{proof}

\begin{theorem}
לכל
$v \in V$
מתקיים
$d(v) \leq dist_G(s,v)$
\end{theorem}
\\
\noindent
מהו זמן הריצה של BFS ? קשה להגיד כי לא הגדרנו כיצד מתבצעת הבדיקה בשלב 
\ref{item:bfs:while}
של האלגוריתם. ניתן לממש שלב זה על ידי תור באופן הבא:
\begin{enumerate}
\item
אתחול:
$U \leftarrow \{s\}, T \leftarrow \emptyset, i \leftarrow 0$, 
לכל 
$v \in V$
מציבים
$p(v) \leftarrow nil, d(v) \leftarrow \infty$,
$d(s) \leftarrow 0, Q \leftarrow (s)$
\item 
כל עוד התור לא ריק וראש התור, $u$, מקיים
$d(u) = i$
\begin{enumerate}
	\item
	כל עוד ישנה קשת 
	$uv$
	שחוצה את $U$
		\begin{enumerate}
		\item
		$U \leftarrow U \cup \{v\}, T \leftarrow T \cup \{uv\}$
		\item
		$p(v) = u, d(v) = i + 1$
		\item
		\textenglish{Q.enqueue($v$)}
		\end{enumerate}
	\item
	$i \leftarrow i+1$
	\end{enumerate}
\end{enumerate}
\\
\noindent
נשים לב שבמימוש הנ"ל כל צומת נכנסת ויוצאת מהתור לכל היותר פעם אחת 
ובנוסף כל קשת נבדקת לכל היותר פעם אחת ולכן זמן הריצה הוא 
$O(|V| + |E|)$













\subsection*{%
חיפוש לעומק - 
\textenglish{Depth First Search (DFS)}
}
נגדיר
\textenglish{dfs($U, T, u$)}
\begin{enumerate}
\item
אם קיימת קשת 
$uv$
שחוצה את $U$ אז
	\begin{enumerate}
	\item
	$U \leftarrow U \cup \{v\}, T \leftarrow T \cup \{uv\}, p(v) \leftarrow u$
	\item
	$\text{dfs}(U, T, v)$
	\end{enumerate}
\end{enumerate}


\begin{center}
\begin{tikzpicture}[every node/.style={circle, draw, minimum width=5mm}]

\node(s) at(0,0) {s};
\foreach [count=\i] \x\y in {-1/-1,1/-1,0/-2}{
	\node(\i) at(\x,\y) {\i};
}

\foreach \u \v in {
s/1%
,s/2%
,1/2%
,1/3%
,2/3%
}{
	\draw (\u) -- (\v);
}

\begin{scope}[xshift=6cm]
\node(s) at(0,0) {s};
\foreach [count=\i] \x\y in {-1/-1,1/-1,0/-2}{
	\node(\i) at(\x,\y) {\i};
}

\foreach \u \v in {
s/1%
,1/2%
,2/3%
}{
	\draw[->] (\u) -- (\v);
}
\end{scope}

\end{tikzpicture}
\end{center}

\subsection*{סיכום}
\begin{example}[פאזל הזזה]
נתון לוח משחק בגודל 
$n \times m$
על הלוח 
$nm - 1$
חלקים ממוספרים מ-1 עד 
$nm - 1$
ומשבצת ריקה.
נתון סידור ראשוני של החלקים ואנו רוצים לסדר את החלקים לפי הסדר 
כך שבכל שלב מותר לנו להזיז את אחד החלקים ששכנים למשבצת הריקה אל המשבצת הריקה.
\end{example}
למשל עבור
$n = m = 3$:
\begin{center}
\begin{tikzpicture}
\draw (0,0) grid (3,3);

\begin{scope}[xshift=.5cm, yshift=.5cm, font=\Large]
\foreach \x \y \i in {0/0/5, 1/0/2, 2/0/7, 0/1/8, 1/1/4, 0/2/1, 1/2/3, 2/2/6}{
	\node at(\x, \y) {\i};
}
\end{scope}

\end{tikzpicture}
\end{center}


הציעו אלגוריתם לפתרון הבעיה.
